#!/usr/bin/env node

/**
 * N0DE Pre-commit Hook - Multi-Agent Security & Quality Check
 * Runs before each git commit to ensure code quality and security
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

console.log('ðŸ” N0DE Pre-commit Multi-Agent Analysis...\n');

// Get staged files
const getStagedFiles = () => {
  try {
    const output = execSync('git diff --cached --name-only', { encoding: 'utf8' });
    return output.trim().split('\n').filter(file => file.length > 0);
  } catch (error) {
    return [];
  }
};

// Route files to appropriate agents based on patterns
const routeFilesToAgents = (files) => {
  const agentAssignments = {
    'security-guardian': [],
    'frontend-specialist': [],
    'backend-api-expert': [],
    'payments-specialist': [],
    'devops-engineer': []
  };

  files.forEach(file => {
    // Security Guardian - auth, security, guards
    if (file.match(/(auth|security|guard|middleware|strategy|jwt|oauth)/i) || 
        file.includes('.env') || 
        file.match(/\.(guard|strategy)\.ts$/)) {
      agentAssignments['security-guardian'].push(file);
    }
    
    // Frontend Specialist - React, Next.js, UI components
    if (file.match(/frontend.*\.(tsx|ts|js|jsx|css|scss)$/) ||
        file.includes('vercel.json') ||
        file.match(/\.(component|page)\.tsx$/)) {
      agentAssignments['frontend-specialist'].push(file);
    }
    
    // Backend API Expert - NestJS services, controllers
    if (file.match(/src.*\.(service|controller|module)\.ts$/) ||
        file.includes('prisma/') ||
        file.match(/nest-cli\.json|tsconfig\.json/)) {
      agentAssignments['backend-api-expert'].push(file);
    }
    
    // Payments Specialist - billing, payments, Stripe
    if (file.match(/(billing|payment|stripe|subscription|checkout)/i)) {
      agentAssignments['payments-specialist'].push(file);
    }
    
    // DevOps Engineer - CI/CD, deployment, monitoring
    if (file.match(/\.(yml|yaml)$/) ||
        file.includes('.github/workflows/') ||
        file.includes('docker') ||
        file.match(/(deploy|monitor|performance|infrastructure)/i)) {
      agentAssignments['devops-engineer'].push(file);
    }
  });

  return agentAssignments;
};

// Run security checks
const runSecurityChecks = (assignments) => {
  console.log('ðŸ”’ Running Security Guardian checks...');
  
  const securityFiles = assignments['security-guardian'];
  let securityIssues = [];
  
  // Check for potential security issues
  securityFiles.forEach(file => {
    if (!fs.existsSync(file)) return;
    
    const content = fs.readFileSync(file, 'utf8');
    
    // Check for hardcoded secrets
    const secretPatterns = [
      /sk_live_[a-zA-Z0-9]+/g,     // Stripe live keys
      /sk_test_[a-zA-Z0-9]+/g,     // Stripe test keys
      /AIza[0-9A-Za-z-_]{35}/g,    // Google API keys
      /github_pat_[a-zA-Z0-9_]+/g, // GitHub tokens
      /password\s*=\s*["'][^"']{8,}/gi // Hardcoded passwords
    ];
    
    secretPatterns.forEach(pattern => {
      const matches = content.match(pattern);
      if (matches) {
        securityIssues.push(`${file}: Potential hardcoded secret detected`);
      }
    });
    
    // Check for dangerous operations
    if (content.includes('eval(') || content.includes('innerHTML')) {
      securityIssues.push(`${file}: Potentially dangerous operation detected`);
    }
  });
  
  if (securityIssues.length > 0) {
    console.error('âŒ Security issues found:');
    securityIssues.forEach(issue => console.error(`  - ${issue}`));
    return false;
  }
  
  console.log('âœ… Security checks passed');
  return true;
};

// Run TypeScript checks
const runTypeScriptChecks = () => {
  console.log('ðŸ“ Running TypeScript checks...');
  
  try {
    execSync('npm run type-check', { stdio: 'pipe' });
    console.log('âœ… TypeScript compilation successful');
    return true;
  } catch (error) {
    console.error('âŒ TypeScript compilation failed');
    console.error(error.stdout?.toString() || error.stderr?.toString());
    return false;
  }
};

// Run linting
const runLinting = () => {
  console.log('ðŸ§¹ Running ESLint checks...');
  
  try {
    execSync('npm run lint', { stdio: 'pipe' });
    console.log('âœ… Linting passed');
    return true;
  } catch (error) {
    console.error('âŒ Linting failed');
    console.error(error.stdout?.toString() || error.stderr?.toString());
    return false;
  }
};

// Run tests for critical components
const runCriticalTests = (assignments) => {
  console.log('ðŸ§ª Running critical component tests...');
  
  const hasAuthChanges = assignments['security-guardian'].length > 0;
  const hasPaymentChanges = assignments['payments-specialist'].length > 0;
  
  let testCommands = [];
  
  if (hasAuthChanges) {
    testCommands.push('npm test -- auth');
  }
  
  if (hasPaymentChanges) {
    testCommands.push('npm test -- payment billing');
  }
  
  for (const command of testCommands) {
    try {
      execSync(command, { stdio: 'pipe' });
      console.log(`âœ… ${command} - Tests passed`);
    } catch (error) {
      console.error(`âŒ ${command} - Tests failed`);
      console.error(error.stdout?.toString() || error.stderr?.toString());
      return false;
    }
  }
  
  console.log('âœ… All critical tests passed');
  return true;
};

// Generate commit impact report
const generateImpactReport = (assignments) => {
  console.log('\nðŸ“Š Commit Impact Report:');
  
  Object.entries(assignments).forEach(([agent, files]) => {
    if (files.length > 0) {
      console.log(`  ${agent}: ${files.length} files modified`);
      files.forEach(file => console.log(`    - ${file}`));
    }
  });
  
  // Risk assessment
  const riskFactors = [];
  if (assignments['security-guardian'].length > 0) riskFactors.push('Security-sensitive changes');
  if (assignments['payments-specialist'].length > 0) riskFactors.push('Payment system changes');
  if (assignments['backend-api-expert'].some(f => f.includes('controller'))) riskFactors.push('API changes');
  
  if (riskFactors.length > 0) {
    console.log('\nâš ï¸  High-impact changes detected:');
    riskFactors.forEach(factor => console.log(`  - ${factor}`));
    console.log('  Consider additional testing and staging deployment first');
  }
};

// Main execution
async function main() {
  const stagedFiles = getStagedFiles();
  
  if (stagedFiles.length === 0) {
    console.log('â„¹ï¸  No staged files found');
    process.exit(0);
  }
  
  const assignments = routeFilesToAgents(stagedFiles);
  
  let allChecksPassed = true;
  
  // Run all checks
  if (!runSecurityChecks(assignments)) allChecksPassed = false;
  if (!runTypeScriptChecks()) allChecksPassed = false;
  if (!runLinting()) allChecksPassed = false;
  if (!runCriticalTests(assignments)) allChecksPassed = false;
  
  // Generate impact report
  generateImpactReport(assignments);
  
  if (!allChecksPassed) {
    console.error('\nâŒ Pre-commit checks failed. Please fix the issues above before committing.');
    process.exit(1);
  }
  
  console.log('\nâœ… All pre-commit checks passed! Proceeding with commit...');
  process.exit(0);
}

main().catch(error => {
  console.error('Error in pre-commit hook:', error);
  process.exit(1);
});